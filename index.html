<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>AppAuth for iOS by openid</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/styles-override.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>AppAuth for iOS</h1>
        <p></p>

        <p class="view"><a href="https://github.com/openid/AppAuth-iOS">View the Project on GitHub <small>openid/AppAuth-iOS</small></a></p>

        <p class="view"><a href="https://openid.github.io/AppAuth-iOS/docs/latest/annotated.html">Browse the API documentation</a></p>


        <ul>
          <li><a href="https://github.com/openid/AppAuth-iOS/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/openid/AppAuth-iOS/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/openid/AppAuth-iOS">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="appauth-for-ios-and-macos" class="anchor" href="#appauth-for-ios-and-macos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AppAuth for iOS and macOS</h1>

<p><a href="https://www.bitrise.io/app/8e4dbca635a964dc"><img src="https://www.bitrise.io/app/8e4dbca635a964dc.svg?token=8rT4oJnhjUuFWH-QvXuJzg&amp;branch=master" alt="Build Status"></a></p>

<p>AppAuth for iOS and macOS is a client SDK for communicating with <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a> and <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a> providers. It strives to
directly map the requests and responses of those specifications, while following
the idiomatic style of the implementation language. In addition to mapping the
raw protocol flows, convenience methods are available to assist with common
tasks like performing an action with fresh tokens.</p>

<p>It follows the best practices set out in <a href="https://tools.ietf.org/html/draft-ietf-oauth-native-apps">OAuth 2.0 for Native Apps</a>
including using <code>SFSafariViewController</code> on iOS for the auth request. For this
reason, <code>UIWebView</code> is explicitly <em>not</em> supported due to usability and security
reasons.</p>

<p>It also supports the <a href="https://tools.ietf.org/html/rfc7636">PKCE</a> extension to
OAuth which was created to secure authorization codes in public clients when
custom URI scheme redirects are used. The library is friendly to other
extensions (standard or otherwise) with the ability to handle additional params
in all protocol requests and responses.</p>

<h2>
<a id="specification" class="anchor" href="#specification" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Specification</h2>

<h3>
<a id="ios" class="anchor" href="#ios" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>iOS</h3>

<h4>
<a id="supported-versions" class="anchor" href="#supported-versions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Supported Versions</h4>

<p>AppAuth supports iOS 7 and above.</p>

<p>iOS 9+ uses the in-app browser tab pattern
(via <code>SFSafariViewController</code>), and falls back to the system browser (mobile
Safari) on earlier versions.</p>

<h4>
<a id="authorization-server-requirements" class="anchor" href="#authorization-server-requirements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authorization Server Requirements</h4>

<p>Both Custom URI Schemes (all supported versions of iOS) and Universal Links
(iOS 9+) can be used with the library.</p>

<p>In general, AppAuth can work with any Authorization Server (AS) that supports
<a href="https://tools.ietf.org/html/draft-ietf-oauth-native-apps">native apps</a>,
either through custom URI scheme redirects, or universal links.
AS's that assume all clients are web-based or require clients to maintain
confidentiality of the client secrets may not work well.</p>

<h3>
<a id="macos" class="anchor" href="#macos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>macOS</h3>

<h4>
<a id="supported-versions-1" class="anchor" href="#supported-versions-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Supported Versions</h4>

<p>AppAuth supports macOS (OS X) 10.8 and above.</p>

<h4>
<a id="authorization-server-requirements-1" class="anchor" href="#authorization-server-requirements-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authorization Server Requirements</h4>

<p>AppAuth for macOS supports both custom schemes, a loopback HTTP redirects
via a small embedded server.</p>

<p>In general, AppAuth can work with any Authorization Server (AS) that supports
<a href="https://tools.ietf.org/html/draft-ietf-oauth-native-apps">native apps</a>,
either through custom URI scheme, or loopback HTTP redirects.
AS's that assume all clients are web-based or require clients to maintain
confidentiality of the client secrets may not work well.</p>

<h2>
<a id="try" class="anchor" href="#try" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Try</h2>

<p>Want to try out AppAuth? Just run:</p>

<pre><code>pod try AppAuth
</code></pre>

<p>Follow the instructions in <a href="Example/README.md">Example/README.md</a> to configure
with your own OAuth client (you need to update 3 configuration points with your
client info to try the demo).</p>

<h2>
<a id="setup" class="anchor" href="#setup" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setup</h2>

<p>If you use <a href="https://guides.cocoapods.org/using/getting-started.html">CocoaPods</a>,
simply add:</p>

<pre><code>pod 'AppAuth'
</code></pre>

<p>To your <code>Podfile</code> and run <code>pod install</code>. Otherwise, add <code>AppAuth.xcodeproj</code>
into your workspace.</p>

<h2>
<a id="auth-flow" class="anchor" href="#auth-flow" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Auth Flow</h2>

<p>AppAuth supports both manual interaction with the Authorization Server
where you need to perform your own token exchanges, as well as convenience
methods that perform some of this logic for you. This example uses the
convenience method which returns either an <code>OIDAuthState</code> object, or an error.</p>

<p><code>OIDAuthState</code> is a class that keeps track of the authorization and token
requests and responses, and provides a convenience method to call an API with
fresh tokens. This is the only object that you need to serialize to retain the
authorization state of the session.</p>

<h3>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h3>

<p>You can configure AppAuth by specifying the endpoints directly:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSURL</span> *authorizationEndpoint =
    [<span class="pl-c1">NSURL</span> <span class="pl-c1">URLWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>https://accounts.google.com/o/oauth2/v2/auth<span class="pl-pds">"</span></span>];
<span class="pl-c1">NSURL</span> *tokenEndpoint =
    [<span class="pl-c1">NSURL</span> <span class="pl-c1">URLWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>https://www.googleapis.com/oauth2/v4/token<span class="pl-pds">"</span></span>];

OIDServiceConfiguration *configuration =
    [[OIDServiceConfiguration <span class="pl-c1">alloc</span>]
        <span class="pl-c1">initWithAuthorizationEndpoint:</span>authorizationEndpoint
                        <span class="pl-c1">tokenEndpoint:</span>tokenEndpoint];

<span class="pl-c">// perform the auth request...</span></pre></div>

<p>Or through discovery:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c1">NSURL</span> *issuer = [<span class="pl-c1">NSURL</span> <span class="pl-c1">URLWithString:</span><span class="pl-s"><span class="pl-pds">@"</span>https://accounts.google.com<span class="pl-pds">"</span></span>];

[OIDAuthorizationService <span class="pl-c1">discoverServiceConfigurationForIssuer:</span>issuer
    <span class="pl-c1">completion:</span>^(OIDServiceConfiguration *_Nullable configuration,
                 <span class="pl-c1">NSError</span> *_Nullable error) {

  <span class="pl-k">if</span> (!configuration) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Error retrieving discovery document: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>,
          [error <span class="pl-c1">localizedDescription</span>]);
    <span class="pl-k">return</span>;
  }

  <span class="pl-c">// perform the auth request...</span>
}];</pre></div>

<h3>
<a id="authorizing-ios" class="anchor" href="#authorizing-ios" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authorizing â€“Â iOS</h3>

<p>First you need to have a property in your AppDelegate to hold the session, in
order to continue the authorization flow from the redirect.</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// property of the app's AppDelegate</span>
@property(nonatomic, strong, nullable)
    <span class="pl-k">id</span>&lt;OIDAuthorizationFlowSession&gt; currentAuthorizationFlow;</pre></div>

<p>And your main class, a property to store the auth state:</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// property of the containing class</span>
@property(nonatomic, strong, nullable) OIDAuthState *authState;</pre></div>

<p>Then, initiate the authorization request. By using the 
<code>authStateByPresentingAuthorizationRequest</code> convenience method, the token
exchange will be performed automatically, and everything will be protected with
PKCE (if the server supports it). AppAuth also allows you to perform these
requests manually. See the <code>authNoCodeExchange</code> method in the included Example
app for a demonstration.</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// builds authentication request</span>
OIDAuthorizationRequest *request =
    [[OIDAuthorizationRequest <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithConfiguration:</span>configuration
                                                  <span class="pl-c1">clientId:</span><span class="pl-c1">kClientID</span>
                                                    <span class="pl-c1">scopes:</span>@[OIDScopeOpenID,
                                                             <span class="pl-c1">OIDScopeProfile</span>]
                                               <span class="pl-c1">redirectURL:</span>KRedirectURI
                                              <span class="pl-c1">responseType:</span>OIDResponseTypeCode
                                      <span class="pl-c1">additionalParameters:</span><span class="pl-c1">nil</span>];

<span class="pl-c">// performs authentication request</span>
AppDelegate *appDelegate =
    (AppDelegate *)[UIApplication <span class="pl-c1">sharedApplication</span>].delegate;
appDelegate.currentAuthorizationFlow =
    [OIDAuthState <span class="pl-c1">authStateByPresentingAuthorizationRequest:</span>request
        <span class="pl-c1">presentingViewController:</span><span class="pl-v">self</span>
                        <span class="pl-c1">callback:</span>^(OIDAuthState *_Nullable authState,
                                   <span class="pl-c1">NSError</span> *_Nullable error) {
  <span class="pl-k">if</span> (authState) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Got authorization tokens. Access token: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>,
          authState.<span class="pl-smi">lastTokenResponse</span>.<span class="pl-smi">accessToken</span>);
    [<span class="pl-v">self</span> <span class="pl-c1">setAuthState:</span>authState];
  } <span class="pl-k">else</span> {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Authorization error: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [error <span class="pl-c1">localizedDescription</span>]);
    [<span class="pl-v">self</span> <span class="pl-c1">setAuthState:</span><span class="pl-c1">nil</span>];
  }
}];</pre></div>

<p><em>Handling the Redirect</em></p>

<p>The authorization response URL is returned to the app via the iOS openURL
app delegate method, so you need to pipe this through to the current
authorization session (created in the previous session).</p>

<div class="highlight highlight-source-objc"><pre>- (<span class="pl-c1">BOOL</span>)application:(UIApplication *)app
            openURL:(<span class="pl-c1">NSURL</span> *)url
            options:(<span class="pl-c1">NSDictionary</span>&lt;<span class="pl-c1">NSString</span> *, <span class="pl-c1">id</span>&gt; *)options {
  <span class="pl-c">// Sends the URL to the current authorization flow (if any) which will</span>
  <span class="pl-c">// process it if it relates to an authorization response.</span>
  <span class="pl-k">if</span> ([_currentAuthorizationFlow <span class="pl-c1">resumeAuthorizationFlowWithURL:</span>url]) {
    _currentAuthorizationFlow = <span class="pl-c1">nil</span>;
    <span class="pl-k">return</span> <span class="pl-c1">YES</span>;
  }

  <span class="pl-c">// Your additional URL handling (if any) goes here.</span>

  <span class="pl-k">return</span> <span class="pl-c1">NO</span>;
}</pre></div>

<h3>
<a id="authorizing-macos" class="anchor" href="#authorizing-macos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authorizing â€“Â MacOS</h3>

<p>On macOS, the most popular way to get the authorization response redirect is to
start a local HTTP server on the loopback interface (limited to incoming
requests from the user's machine only). When the authorization is complete, the
user is redirected to that local server, and the authorization response can be
processed by the app. AppAuth takes care of managing the local HTTP server
lifecycle for you.</p>

<blockquote>
<h4>
<a id="bulb-alternative-custom-uri-schemes" class="anchor" href="#bulb-alternative-custom-uri-schemes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><g-emoji alias="bulb" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4a1.png" ios-version="6.0">ðŸ’¡</g-emoji> Alternative: Custom URI Schemes</h4>

<p>Custom URI schemes are also supported on macOS, but some browsers display
an interstitial which reduces the usability. For an example on using custom
URI schemes with macOS, See <code>Example-Mac</code>.</p>
</blockquote>

<p>To receive the authorization response using a local HTTP server, first you need
to have an instance variable in your main class to retain the HTTP redirect
handler.</p>

<div class="highlight highlight-source-objc"><pre>OIDRedirectHTTPHandler *_redirectHTTPHandler;</pre></div>

<p>Then, as the port used by the local HTTP server varies, you need to start it
before building the authorization request in order to get the exact redirect
URI to use.</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-k">static</span> <span class="pl-c1">NSString</span> *<span class="pl-k">const</span> <span class="pl-c1">kSuccessURLString</span> =
    <span class="pl-s"><span class="pl-pds">@"</span>http://openid.github.io/AppAuth-iOS/redirect/<span class="pl-pds">"</span></span>;
<span class="pl-c1">NSURL</span> *successURL = [<span class="pl-c1">NSURL</span> <span class="pl-c1">URLWithString:</span><span class="pl-c1">kSuccessURLString</span>];

<span class="pl-c">// Starts a loopback HTTP redirect listener to receive the code.  This needs to be started first,</span>
<span class="pl-c">// as the exact redirect URI (including port) must be passed in the authorization request.</span>
_redirectHTTPHandler = [[OIDRedirectHTTPHandler <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithSuccessURL:</span>successURL];
<span class="pl-c1">NSURL</span> *redirectURI = [_redirectHTTPHandler <span class="pl-c1">startHTTPListener:</span><span class="pl-c1">nil</span>];</pre></div>

<p>Then, initiate the authorization request. By using the 
<code>authStateByPresentingAuthorizationRequest</code> convenience method, the token
exchange will be performed automatically, and everything will be protected with
PKCE (if the server supports it). By assigning the return value to the
<code>OIDRedirectHTTPHandler</code>'s <code>currentAuthorizationFlow</code>, the authorization will
continue automatically once the user makes their choice.</p>

<div class="highlight highlight-source-objc"><pre><span class="pl-c">// builds authentication request</span>
OIDAuthorizationRequest *request =
    [[OIDAuthorizationRequest <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithConfiguration:</span>configuration
                                                  <span class="pl-c1">clientId:</span><span class="pl-c1">kClientID</span>
                                              <span class="pl-c1">clientSecret:</span><span class="pl-c1">kClientSecret</span>
                                                    <span class="pl-c1">scopes:</span>@[ OIDScopeOpenID ]
                                               <span class="pl-c1">redirectURL:</span>redirectURI
                                              <span class="pl-c1">responseType:</span>OIDResponseTypeCode
                                      <span class="pl-c1">additionalParameters:</span><span class="pl-c1">nil</span>];
<span class="pl-c">// performs authentication request</span>
__weak <span class="pl-en">__typeof</span>(self) weakSelf = self;
_redirectHTTPHandler.currentAuthorizationFlow =
    [OIDAuthState <span class="pl-c1">authStateByPresentingAuthorizationRequest:</span>request
                        <span class="pl-c1">callback:</span>^(OIDAuthState *_Nullable authState,
                                   <span class="pl-c1">NSError</span> *_Nullable error) {
  <span class="pl-c">// Brings this app to the foreground.</span>
  [[<span class="pl-c1">NSRunningApplication</span> <span class="pl-c1">currentApplication</span>]
      <span class="pl-c1">activateWithOptions:</span>(NSApplicationActivateAllWindows |
                           NSApplicationActivateIgnoringOtherApps)];

  <span class="pl-c">// Processes the authorization response.</span>
  <span class="pl-k">if</span> (authState) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Got authorization tokens. Access token: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>,
          authState.<span class="pl-smi">lastTokenResponse</span>.<span class="pl-smi">accessToken</span>);
  } <span class="pl-k">else</span> {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Authorization error: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, error.<span class="pl-smi">localizedDescription</span>);
  }
  [weakSelf <span class="pl-c1">setAuthState:</span>authState];
}];</pre></div>

<h3>
<a id="making-api-calls" class="anchor" href="#making-api-calls" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Making API Calls</h3>

<p>AppAuth gives you the raw token information, if you need it. However we
recommend that users of the <code>OIDAuthState</code> convenience wrapper use the provided
<code>performActionWithFreshTokens:</code> method to perform their API calls to avoid
needing to worry about token freshness.</p>

<div class="highlight highlight-source-objc"><pre>[_authState <span class="pl-c1">performActionWithFreshTokens:</span>^(<span class="pl-c1">NSString</span> *_Nonnull accessToken,
                                           <span class="pl-c1">NSString</span> *_Nonnull idToken,
                                           <span class="pl-c1">NSError</span> *_Nullable error) {
  <span class="pl-k">if</span> (error) {
    <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span>Error fetching fresh tokens: <span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [error <span class="pl-c1">localizedDescription</span>]);
    <span class="pl-k">return</span>;
  }

  <span class="pl-c">// perform your API request using the tokens</span>
}];</pre></div>

<h2>
<a id="api-documentation" class="anchor" href="#api-documentation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>API Documentation</h2>

<p>Browse the <a href="http://openid.github.io/AppAuth-iOS/docs/latest/annotated.html">API documentation</a>.</p>

<h2>
<a id="included-samples" class="anchor" href="#included-samples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Included Samples</h2>

<p>You can try out the iOS sample included in the source distribution by opening
<code>Example/Example.xcworkspace</code>. You can easily convert the Example
workspace to a Pod workspace by deleting the <code>AppAuth</code> project, and
<a href="#setup">configuring the pod</a>. You can also
<a href="#try">try out the sample via CocoaPods</a>. Be sure to follow the instructions in
<a href="Example/README.md">Example/README.md</a> to configure your own OAuth client ID
for use with the example.</p>

<p>You can try out the macOS sample included in the source distribution by
executing <code>pod install</code> in the <code>Example-Mac</code> folder, then opening 
<code>Example-Mac.xcworkspace</code>. Be sure to follow the instructions in
<a href="Example-Mac/README.md">Example-Mac/README.md</a> to configure your own OAuth
client ID for use with the example.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/openid">openid</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
